import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __commonJS
} from "./chunk-DC5AMYBS.js";

// node_modules/fluid-simulation-react/dist/gl-program.js
var require_gl_program = __commonJS({
  "node_modules/fluid-simulation-react/dist/gl-program.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function compileShader(gl, type, source) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw gl.getShaderInfoLog(shader);
      }
      return shader;
    }
    var GLProgram = exports["default"] = function() {
      function GLProgram2(gl, vertexSource, fragmentSource) {
        _classCallCheck(this, GLProgram2);
        var vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSource);
        var fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
        this.uniforms = {};
        this.program = gl.createProgram();
        this.gl = gl;
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
          throw gl.getProgramInfoLog(this.program);
        }
        var uniformCount = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);
        for (var i = 0; i < uniformCount; i++) {
          var uniformName = gl.getActiveUniform(this.program, i).name;
          this.uniforms[uniformName] = gl.getUniformLocation(this.program, uniformName);
        }
      }
      _createClass(GLProgram2, [{
        key: "bind",
        value: function bind() {
          this.gl.useProgram(this.program);
        }
      }]);
      return GLProgram2;
    }();
  }
});

// node_modules/fluid-simulation-react/dist/get-gl-context.js
var require_get_gl_context = __commonJS({
  "node_modules/fluid-simulation-react/dist/get-gl-context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = getWebGLContext;
    function getWebGLContext(canvas) {
      var params = {
        alpha: false,
        depth: false,
        stencil: false,
        antialias: false
      };
      var gl = canvas.getContext("webgl2", params);
      var isWebGL2 = !!gl;
      if (!isWebGL2) {
        gl = canvas.getContext("webgl", params) || canvas.getContext("experimental-webgl", params);
      }
      var halfFloat;
      var supportLinearFiltering;
      if (isWebGL2) {
        gl.getExtension("EXT_color_buffer_float");
        supportLinearFiltering = gl.getExtension("OES_texture_float_linear");
      } else {
        halfFloat = gl.getExtension("OES_texture_half_float");
        supportLinearFiltering = gl.getExtension("OES_texture_half_float_linear");
      }
      gl.clearColor(0, 0, 0, 1);
      var halfFloatTexType = isWebGL2 ? gl.HALF_FLOAT : halfFloat.HALF_FLOAT_OES;
      var formatRGBA;
      var formatRG;
      var formatR;
      if (isWebGL2) {
        formatRGBA = getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, halfFloatTexType);
        formatRG = getSupportedFormat(gl, gl.RG16F, gl.RG, halfFloatTexType);
        formatR = getSupportedFormat(gl, gl.R16F, gl.RED, halfFloatTexType);
      } else {
        formatRGBA = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
        formatRG = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
        formatR = getSupportedFormat(gl, gl.RGBA, gl.RGBA, halfFloatTexType);
      }
      return {
        gl,
        ext: {
          formatRGBA,
          formatRG,
          formatR,
          halfFloatTexType,
          supportLinearFiltering
        }
      };
    }
    function getSupportedFormat(gl, internalFormat, format, type) {
      if (!supportRenderTextureFormat(gl, internalFormat, format, type)) {
        switch (internalFormat) {
          case gl.R16F:
            return getSupportedFormat(gl, gl.RG16F, gl.RG, type);
          case gl.RG16F:
            return getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
          default:
            return null;
        }
      }
      return {
        internalFormat,
        format
      };
    }
    function supportRenderTextureFormat(gl, internalFormat, format, type) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 4, 4, 0, format, type, null);
      var fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      if (status !== gl.FRAMEBUFFER_COMPLETE) return false;
      return true;
    }
  }
});

// node_modules/fluid-simulation-react/dist/shaders/advection-manual-filtering.js
var require_advection_manual_filtering = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/advection-manual-filtering.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform float dt;\nuniform float dissipation;\n\nvec4 bilerp (in sampler2D sam, in vec2 p) {\n  vec4 st;\n  st.xy = floor(p - 0.5) + 0.5;\n  st.zw = st.xy + 1.0;\n  vec4 uv = st * texelSize.xyxy;\n  vec4 a = texture2D(sam, uv.xy);\n  vec4 b = texture2D(sam, uv.zy);\n  vec4 c = texture2D(sam, uv.xw);\n  vec4 d = texture2D(sam, uv.zw);\n  vec2 f = p - st.xy;\n  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvoid main () {\n  vec2 coord = gl_FragCoord.xy - dt * texture2D(uVelocity, vUv).xy;\n  gl_FragColor = dissipation * bilerp(uSource, coord);\n  gl_FragColor.a = 1.0;\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/advection.js
var require_advection = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/advection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uVelocity;\nuniform sampler2D uSource;\nuniform vec2 texelSize;\nuniform float dt;\nuniform float dissipation;\n\nvoid main () {\n  vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n  gl_FragColor = dissipation * texture2D(uSource, coord);\n  gl_FragColor.a = 1.0;\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/clear.js
var require_clear = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/clear.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\nuniform float value;\n\nvoid main () {\n  gl_FragColor = value * texture2D(uTexture, vUv);\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/curl.js
var require_curl = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/curl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvoid main () {\n  float L = texture2D(uVelocity, vL).y;\n  float R = texture2D(uVelocity, vR).y;\n  float T = texture2D(uVelocity, vT).x;\n  float B = texture2D(uVelocity, vB).x;\n  float vorticity = R - L - T + B;\n  gl_FragColor = vec4(vorticity, 0.0, 0.0, 1.0);\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/display.js
var require_display = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/display.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTexture;\n\nvoid main () {\n  gl_FragColor = texture2D(uTexture, vUv);\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/divergence.js
var require_divergence = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/divergence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\n\nvec2 sampleVelocity (in vec2 uv) {\n  vec2 multiplier = vec2(1.0, 1.0);\n  if (uv.x < 0.0) { uv.x = 0.0; multiplier.x = -1.0; };\n  if (uv.x > 1.0) { uv.x = 1.0; multiplier.x = -1.0; };\n  if (uv.y < 0.0) { uv.y = 0.0; multiplier.y = -1.0; };\n  if (uv.y > 1.0) { uv.y = 1.0; multiplier.y = -1.0; };\n  return multiplier * texture2D(uVelocity, uv).xy;\n}\n\nvoid main () {\n  float L = sampleVelocity(vL).x;\n  float R = sampleVelocity(vR).x;\n  float T = sampleVelocity(vT).y;\n  float B = sampleVelocity(vB).y;\n  float div = 0.5 * (R - L + T - B);\n  gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/gradient-subtract.js
var require_gradient_subtract = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/gradient-subtract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uVelocity;\n\nvec2 boundary (in vec2 uv) {\n  uv = min(max(uv, 0.0), 1.0);\n  return uv;\n}\n\nvoid main () {\n  float L = texture2D(uPressure, boundary(vL)).x;\n  float R = texture2D(uPressure, boundary(vR)).x;\n  float T = texture2D(uPressure, boundary(vT)).x;\n  float B = texture2D(uPressure, boundary(vB)).x;\n  vec2 velocity = texture2D(uVelocity, vUv).xy;\n  velocity.xy -= vec2(R - L, T - B);\n  gl_FragColor = vec4(velocity, 0.0, 1.0);\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/pressure.js
var require_pressure = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/pressure.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uPressure;\nuniform sampler2D uDivergence;\n\nvec2 boundary (in vec2 uv) {\n  uv = min(max(uv, 0.0), 1.0);\n  return uv;\n}\n\nvoid main () {\n  float L = texture2D(uPressure, boundary(vL)).x;\n  float R = texture2D(uPressure, boundary(vR)).x;\n  float T = texture2D(uPressure, boundary(vT)).x;\n  float B = texture2D(uPressure, boundary(vB)).x;\n  float C = texture2D(uPressure, vUv).x;\n  float divergence = texture2D(uDivergence, vUv).x;\n  float pressure = (L + R + B + T - divergence) * 0.25;\n  gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/splat.js
var require_splat = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/splat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nuniform sampler2D uTarget;\nuniform float aspectRatio;\nuniform vec3 color;\nuniform vec2 point;\nuniform float radius;\n\nvoid main () {\n  vec2 p = vUv - point.xy;\n  p.x *= aspectRatio;\n  vec3 splat = exp(-dot(p, p) / radius) * color;\n  vec3 base = texture2D(uTarget, vUv).xyz;\n  gl_FragColor = vec4(base + splat, 1.0);\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/vert.js
var require_vert = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/vert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nattribute vec2 aPosition;\nvarying vec2 vUv;\nvarying vec2 vL;\nvarying vec2 vR;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform vec2 texelSize;\n\nvoid main () {\n  vUv = aPosition * 0.5 + 0.5;\n  vL = vUv - vec2(texelSize.x, 0.0);\n  vR = vUv + vec2(texelSize.x, 0.0);\n  vT = vUv + vec2(0.0, texelSize.y);\n  vB = vUv - vec2(0.0, texelSize.y);\n  gl_Position = vec4(aPosition, 0.0, 1.0);\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/vorticity.js
var require_vorticity = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/vorticity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = exports["default"] = "\nprecision highp float;\nprecision mediump sampler2D;\n\nvarying vec2 vUv;\nvarying vec2 vT;\nvarying vec2 vB;\nuniform sampler2D uVelocity;\nuniform sampler2D uCurl;\nuniform float curl;\nuniform float dt;\n\nvoid main () {\n  float T = texture2D(uCurl, vT).x;\n  float B = texture2D(uCurl, vB).x;\n  float C = texture2D(uCurl, vUv).x;\n  vec2 force = vec2(abs(T) - abs(B), 0.0);\n  force *= 1.0 / length(force + 0.00001) * curl * C;\n  vec2 vel = texture2D(uVelocity, vUv).xy;\n  gl_FragColor = vec4(vel + force * dt, 0.0, 1.0);\n}\n";
  }
});

// node_modules/fluid-simulation-react/dist/shaders/index.js
var require_shaders = __commonJS({
  "node_modules/fluid-simulation-react/dist/shaders/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _advectionManualFiltering = _interopRequireDefault(require_advection_manual_filtering());
    var _advection = _interopRequireDefault(require_advection());
    var _clear = _interopRequireDefault(require_clear());
    var _curl = _interopRequireDefault(require_curl());
    var _display = _interopRequireDefault(require_display());
    var _divergence = _interopRequireDefault(require_divergence());
    var _gradientSubtract = _interopRequireDefault(require_gradient_subtract());
    var _pressure = _interopRequireDefault(require_pressure());
    var _splat = _interopRequireDefault(require_splat());
    var _vert = _interopRequireDefault(require_vert());
    var _vorticity = _interopRequireDefault(require_vorticity());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _default = exports["default"] = {
      advectionManualFiltering: _advectionManualFiltering["default"],
      advection: _advection["default"],
      clear: _clear["default"],
      curl: _curl["default"],
      display: _display["default"],
      divergence: _divergence["default"],
      gradientSubtract: _gradientSubtract["default"],
      pressure: _pressure["default"],
      splat: _splat["default"],
      vert: _vert["default"],
      vorticity: _vorticity["default"]
    };
  }
});

// node_modules/fluid-simulation-react/dist/fluid-animation.js
var require_fluid_animation = __commonJS({
  "node_modules/fluid-simulation-react/dist/fluid-animation.js"(exports) {
    "use strict";
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.defaultConfig = exports["default"] = void 0;
    var _glProgram = _interopRequireDefault(require_gl_program());
    var _getGlContext = _interopRequireDefault(require_get_gl_context());
    var _shaders = _interopRequireDefault(require_shaders());
    var _react = _interopRequireWildcard(require_react());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define({}, "");
      } catch (t2) {
        define = function define2(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw new Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
      }), define(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw new Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, "catch": function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw new Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    var defaultConfig = exports.defaultConfig = {
      textureDownsample: 1,
      densityDissipation: 0.98,
      velocityDissipation: 0.99,
      pressureDissipation: 0.8,
      pressureIterations: 25,
      curl: 30,
      splatRadius: 5e-3
    };
    var Pointer = function Pointer2() {
      return {
        id: -1,
        x: 0,
        y: 0,
        dx: 0,
        dy: 0,
        down: false,
        moved: false,
        color: [30, 0, 300]
      };
    };
    var FluidAnimation = function FluidAnimation2(_ref) {
      var _ref$opts = _ref.opts, opts = _ref$opts === void 0 ? {} : _ref$opts;
      var config = opts.config, userColors = opts.color;
      var canvasRef = (0, _react.useRef)(null);
      var glRef = (0, _react.useRef)(null);
      var extRef = (0, _react.useRef)(null);
      var programsRef = (0, _react.useRef)({});
      var textureWidthRef = (0, _react.useRef)(null);
      var textureHeightRef = (0, _react.useRef)(null);
      var densityRef = (0, _react.useRef)(null);
      var velocityRef = (0, _react.useRef)(null);
      var divergenceRef = (0, _react.useRef)(null);
      var curlRef = (0, _react.useRef)(null);
      var pressureRef = (0, _react.useRef)(null);
      var timeRef = (0, _react.useRef)(Date.now());
      var timerRef = (0, _react.useRef)(0);
      var pointersRef = (0, _react.useRef)([Pointer()]);
      (0, _react.useEffect)(function() {
        var canvas = canvasRef.current;
        if (!canvas) return;
        var width = canvas.offsetWidth;
        var height = canvas.offsetHeight;
        if (canvas.width !== width || canvas.height !== height) {
          canvasRef.current.width = width;
          canvasRef.current.height = height;
        }
        var _getGLContext = (0, _getGlContext["default"])(canvas), gl = _getGLContext.gl, ext = _getGLContext.ext;
        glRef.current = gl;
        extRef.current = ext;
        gl.getError();
        var programs = initPrograms(gl, ext);
        programsRef.current = programs;
        initFramebuffers(gl, ext);
        initBlit(gl);
      }, []);
      var initPrograms = function initPrograms2(gl, ext) {
        var programs = {};
        programs.clear = new _glProgram["default"](gl, _shaders["default"].vert, _shaders["default"].clear);
        programs.display = new _glProgram["default"](gl, _shaders["default"].vert, _shaders["default"].display);
        programs.splat = new _glProgram["default"](gl, _shaders["default"].vert, _shaders["default"].splat);
        programs.advection = new _glProgram["default"](gl, _shaders["default"].vert, ext.supportLinearFiltering ? _shaders["default"].advection : _shaders["default"].advectionManualFiltering);
        programs.divergence = new _glProgram["default"](gl, _shaders["default"].vert, _shaders["default"].divergence);
        programs.curl = new _glProgram["default"](gl, _shaders["default"].vert, _shaders["default"].curl);
        programs.vorticity = new _glProgram["default"](gl, _shaders["default"].vert, _shaders["default"].vorticity);
        programs.pressure = new _glProgram["default"](gl, _shaders["default"].vert, _shaders["default"].pressure);
        programs.gradientSubtract = new _glProgram["default"](gl, _shaders["default"].vert, _shaders["default"].gradientSubtract);
        return programs;
      };
      var initFramebuffers = function initFramebuffers2(gl, ext) {
        var createFBO = function createFBO2(texId, w, h, internalFormat, format, type, param) {
          gl.activeTexture(gl.TEXTURE0 + texId);
          var texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, w, h, 0, format, type, null);
          var fbo = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          gl.viewport(0, 0, w, h);
          gl.clear(gl.COLOR_BUFFER_BIT);
          return [texture, fbo, texId];
        };
        var createDoubleFBO = function createDoubleFBO2(texId, w, h, internalFormat, format, type, param) {
          var fbo1 = createFBO(texId, w, h, internalFormat, format, type, param);
          var fbo2 = createFBO(texId + 1, w, h, internalFormat, format, type, param);
          return {
            get read() {
              return fbo1;
            },
            get write() {
              return fbo2;
            },
            swap: function swap() {
              var temp = fbo1;
              fbo1 = fbo2;
              fbo2 = temp;
            }
          };
        };
        textureWidthRef.current = gl.drawingBufferWidth >> defaultConfig.textureDownsample;
        textureHeightRef.current = gl.drawingBufferHeight >> defaultConfig.textureDownsample;
        var texType = ext.halfFloatTexType;
        var rgba = ext.formatRGBA;
        var rg = ext.formatRG;
        var r = ext.formatR;
        densityRef.current = createDoubleFBO(2, textureWidthRef.current, textureHeightRef.current, rgba.internalFormat, rgba.format, texType, ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST);
        velocityRef.current = createDoubleFBO(0, textureWidthRef.current, textureHeightRef.current, rg.internalFormat, rg.format, texType, ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST);
        divergenceRef.current = createFBO(4, textureWidthRef.current, textureHeightRef.current, r.internalFormat, r.format, texType, gl.NEAREST);
        curlRef.current = createFBO(5, textureWidthRef.current, textureHeightRef.current, r.internalFormat, r.format, texType, gl.NEAREST);
        pressureRef.current = createDoubleFBO(6, textureWidthRef.current, textureHeightRef.current, r.internalFormat, r.format, texType, gl.NEAREST);
      };
      var getRandomColor = function getRandomColor2() {
        if (userColors && Array.isArray(userColors) && userColors.length > 0) {
          var randomIndex = Math.floor(Math.random() * userColors.length);
          return userColors[randomIndex];
        } else {
          return [Math.random() + 0.2, Math.random() + 0.2, Math.random() + 0.2];
        }
      };
      var onMouseMove = function onMouseMove2(e) {
        var pointer = pointersRef.current[0];
        pointer.down = true;
        pointer.moved = true;
        pointer.dx = (e.clientX - pointer.x) * 10;
        pointer.dy = (e.clientY - pointer.y) * 10;
        pointer.x = e.clientX;
        pointer.y = e.clientY;
        pointer.color = getRandomColor();
      };
      var onMouseDown = function onMouseDown2(e) {
        var pointer = pointersRef.current;
        pointer.down = true;
        pointer.color = getRandomColor();
      };
      var onMouseUp = function onMouseUp2(e) {
        var pointer = pointersRef.current;
        pointer.down = false;
        pointer.moved = false;
      };
      var onTouchStart = function onTouchStart2(e) {
        for (var i = 0; i < e.touches.length; ++i) {
          if (pointersRef.current[i]) {
            pointersRef.current[i].down = true;
            pointersRef.current[i].color = getRandomColor();
          } else {
            pointersRef.current[i] = {
              down: true,
              x: 0,
              y: 0,
              dx: 0,
              dy: 0,
              color: [1, 0, 0]
            };
          }
        }
      };
      var onTouchMove = function onTouchMove2(e) {
        for (var i = 0; i < e.touches.length; ++i) {
          var touch = e.touches[i];
          var pointer = pointersRef.current[i];
          pointer.moved = true;
          pointer.dx = (touch.clientX - pointer.x) * 10;
          pointer.dy = (touch.clientY - pointer.y) * 10;
          pointer.x = touch.clientX;
          pointer.y = touch.clientY;
        }
      };
      var onTouchEnd = function onTouchEnd2(e) {
        pointersRef.current.forEach(function(pointer) {
          pointer.down = false;
        });
      };
      var initBlit = function initBlit2(gl) {
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), gl.STATIC_DRAW);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
      };
      var blit = function blit2(destination) {
        var gl = glRef.current;
        gl.bindFramebuffer(gl.FRAMEBUFFER, destination);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
      };
      var splat = function splat2(gl, x, y, dx, dy, color) {
        programsRef.current.splat.bind();
        gl.uniform1i(programsRef.current.splat.uniforms.uTarget, velocityRef.current.read[2]);
        gl.uniform1f(programsRef.current.splat.uniforms.aspectRatio, canvasRef.current.width / canvasRef.current.height);
        gl.uniform2f(programsRef.current.splat.uniforms.point, x / canvasRef.current.width, 1 - y / canvasRef.current.height);
        gl.uniform3f(programsRef.current.splat.uniforms.color, dx, -dy, 1);
        gl.uniform1f(programsRef.current.splat.uniforms.radius, config.splatRadius);
        blit(velocityRef.current.write[1]);
        velocityRef.current.swap();
        gl.uniform1i(programsRef.current.splat.uniforms.uTarget, densityRef.current.read[2]);
        gl.uniform3f(programsRef.current.splat.uniforms.color, color[0] * 0.3, color[1] * 0.3, color[2] * 0.3);
        blit(densityRef.current.write[1]);
        densityRef.current.swap();
      };
      (0, _react.useEffect)(function() {
        var animationFrameId;
        var update = function() {
          var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
            var gl, now, dt, w, h, iW, iH, i, pointer, pressureTexId, _i;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  gl = glRef.current;
                  now = Date.now();
                  dt = Math.min((now - timeRef.current) / 1e3, 0.016);
                  timeRef.current = now;
                  timerRef.current += 1e-4;
                  w = textureWidthRef.current;
                  h = textureHeightRef.current;
                  iW = 1 / w;
                  iH = 1 / h;
                  gl.viewport(0, 0, w, h);
                  programsRef.current.advection.bind();
                  gl.uniform2f(programsRef.current.advection.uniforms.texelSize, iW, iH);
                  gl.uniform1i(programsRef.current.advection.uniforms.uVelocity, velocityRef.current.read[2]);
                  gl.uniform1i(programsRef.current.advection.uniforms.uSource, velocityRef.current.read[2]);
                  gl.uniform1f(programsRef.current.advection.uniforms.dt, dt);
                  gl.uniform1f(programsRef.current.advection.uniforms.dissipation, config.velocityDissipation);
                  blit(velocityRef.current.write[1]);
                  velocityRef.current.swap();
                  gl.uniform1i(programsRef.current.advection.uniforms.uVelocity, velocityRef.current.read[2]);
                  gl.uniform1i(programsRef.current.advection.uniforms.uSource, densityRef.current.read[2]);
                  gl.uniform1f(programsRef.current.advection.uniforms.dissipation, config.densityDissipation);
                  blit(densityRef.current.write[1]);
                  densityRef.current.swap();
                  for (i = 0; i < pointersRef.current.length; i++) {
                    pointer = pointersRef.current[i];
                    if (pointer.moved) {
                      splat(gl, pointer.x, pointer.y, pointer.dx, pointer.dy, pointer.color);
                      pointer.moved = false;
                    }
                  }
                  programsRef.current.curl.bind();
                  gl.uniform2f(programsRef.current.curl.uniforms.texelSize, iW, iH);
                  gl.uniform1i(programsRef.current.curl.uniforms.uVelocity, velocityRef.current.read[2]);
                  blit(curlRef.current[1]);
                  programsRef.current.vorticity.bind();
                  gl.uniform2f(programsRef.current.vorticity.uniforms.texelSize, iW, iH);
                  gl.uniform1i(programsRef.current.vorticity.uniforms.uVelocity, velocityRef.current.read[2]);
                  gl.uniform1i(programsRef.current.vorticity.uniforms.uCurl, curlRef.current[2]);
                  gl.uniform1f(programsRef.current.vorticity.uniforms.curl, config.curl);
                  gl.uniform1f(programsRef.current.vorticity.uniforms.dt, dt);
                  blit(velocityRef.current.write[1]);
                  velocityRef.current.swap();
                  programsRef.current.divergence.bind();
                  gl.uniform2f(programsRef.current.divergence.uniforms.texelSize, iW, iH);
                  gl.uniform1i(programsRef.current.divergence.uniforms.uVelocity, velocityRef.current.read[2]);
                  blit(divergenceRef.current[1]);
                  programsRef.current.clear.bind();
                  pressureTexId = pressureRef.current.read[2];
                  gl.activeTexture(gl.TEXTURE0 + pressureTexId);
                  gl.bindTexture(gl.TEXTURE_2D, pressureRef.current.read[0]);
                  gl.uniform1i(programsRef.current.clear.uniforms.uTexture, pressureTexId);
                  gl.uniform1f(programsRef.current.clear.uniforms.value, config.pressureDissipation);
                  blit(pressureRef.current.write[1]);
                  pressureRef.current.swap();
                  programsRef.current.pressure.bind();
                  gl.uniform2f(programsRef.current.pressure.uniforms.texelSize, iW, iH);
                  gl.uniform1i(programsRef.current.pressure.uniforms.uDivergence, divergenceRef.current[2]);
                  pressureTexId = pressureRef.current.read[2];
                  gl.uniform1i(programsRef.current.pressure.uniforms.uPressure, pressureTexId);
                  gl.activeTexture(gl.TEXTURE0 + pressureTexId);
                  for (_i = 0; _i < config.pressureIterations; _i++) {
                    gl.bindTexture(gl.TEXTURE_2D, pressureRef.current.read[0]);
                    blit(pressureRef.current.write[1]);
                    pressureRef.current.swap();
                  }
                  programsRef.current.gradientSubtract.bind();
                  gl.uniform2f(programsRef.current.gradientSubtract.uniforms.texelSize, iW, iH);
                  gl.uniform1i(programsRef.current.gradientSubtract.uniforms.uPressure, pressureRef.current.read[2]);
                  gl.uniform1i(programsRef.current.gradientSubtract.uniforms.uVelocity, velocityRef.current.read[2]);
                  blit(velocityRef.current.write[1]);
                  velocityRef.current.swap();
                  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
                  programsRef.current.display.bind();
                  gl.uniform1i(programsRef.current.display.uniforms.uTexture, densityRef.current.read[2]);
                  blit(null);
                  animationFrameId = requestAnimationFrame(update);
                case 66:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function update2() {
            return _ref2.apply(this, arguments);
          };
        }();
        animationFrameId = requestAnimationFrame(update);
        return function() {
          cancelAnimationFrame(animationFrameId);
        };
      }, []);
      return _react["default"].createElement("canvas", {
        ref: canvasRef,
        onMouseMove,
        onMouseDown,
        onMouseUp,
        onTouchStart,
        onTouchMove,
        onTouchEnd,
        style: {
          width: "100%",
          height: "100%"
        }
      });
    };
    var _default = exports["default"] = FluidAnimation;
  }
});

// node_modules/fluid-simulation-react/dist/App.js
var require_App = __commonJS({
  "node_modules/fluid-simulation-react/dist/App.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireDefault(require_react());
    var _fluidAnimation = _interopRequireWildcard(require_fluid_animation());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var FluidSimulation = function FluidSimulation2(_ref) {
      var _ref$config = _ref.config, config = _ref$config === void 0 ? {} : _ref$config, _ref$color = _ref.color, color = _ref$color === void 0 ? null : _ref$color;
      var mergedConfig = _objectSpread(_objectSpread({}, _fluidAnimation.defaultConfig), config);
      return _react["default"].createElement("div", {
        style: {
          width: "100%",
          height: "100%"
        }
      }, _react["default"].createElement(_fluidAnimation["default"], {
        opts: {
          config: mergedConfig,
          color
        }
      }));
    };
    var _default = exports["default"] = FluidSimulation;
  }
});

// node_modules/fluid-simulation-react/dist/index.js
var require_dist = __commonJS({
  "node_modules/fluid-simulation-react/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _App = _interopRequireDefault(require_App());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _default = exports["default"] = _App["default"];
  }
});
export default require_dist();
/*! Bundled license information:

fluid-simulation-react/dist/fluid-animation.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
//# sourceMappingURL=fluid-simulation-react.js.map
